# Оптимизация хэш-таблицы

## О работе

В данной работе реализована хэш-таблица с разрешением коллизий методом цепочек. **Цель работы**: оптимизировать хэш-таблицу, то есть уменьшить время работы ее операций. Для этого в работе производится сравнение различных хэш-функций с целью выбрать оптимальную. Кроме того, анализируется время работы операций таблицы и модифицируется исходный код тех из них, что затрачивают наибольшее время.

## О хэш-таблице с методом цепочек

Хэш-таблица -- это структура данных, хранящая пары ключ-значение (и то, и другое может быть любым типом данных) и позволяющая получать значение по своему ключу в среднем за O(1). Хэш-таблица похожа на  массив, но в массиве ключи -- это числа от $0$ до $N-1$, где $N$ -- размер массива. В хэш-таблице ключи могут быть любыми, например, строковыми переменными. Именно такие ключи и используются в работе. Значениями в работе являются количества вхождения конкретного слова в заданный текст.

Хэш-таблицу можно хранить как массив. Но для этого необходимо отобразить ключи на множество $\{0, 1, \cdots, N-1\}$. Этим занимается хэш функция. Однако неизбежны коллизии, то есть совпадения значений хэш-функции для различающихся ключей.

Существуют разные способы разрешения коллизий, но в данной работе используется метод цепочек. Он заключается в следующем: для каждого значения хэш-функции в хэш-таблице есть связный список (неважно, односвязный или двусвязный), узлы которого есть пары ключей, для которых значение хэш-функции соответствует данному списку, и их значений. Тогда, если размеры всех списков небольшие и примерно одинаковые, хэш-таблица будет иметь в среднем константное время работы (не учитывая время работы хэш-функции). Отсюда заключаем, что важно подобрать хэш-функцию, дающую распределение ключей по спискам, близкое к равномерному.

## Часть 1. Поиск оптимальной хэш-функции

Для сравнения хэш функций в качестве исходных данных был взят текст, состоящий из 25000 попарно различных английских слов. Выбранный размер хэш-таблицы 4096. Тогда load factor примерно равен 6.
После загрузки исходных данных размеры списков, полученных при работе данной хэш-функции, записывались в файл. На их основе были построены гистограммы, представленные в работе.
Также в работе представлена сравнительная таблица с дисперсиями для рассмотренных функций.

Реализации тестируемых хэш-функций расположены в файле **hash_functions.h**.

### 1. Константная хэш-функция

Реализована функция `hashAlways1()`, которая всегда возвращает число $1$. Это очень плохая хэш-функция, так как она сводит адресацию в хэш-таблице к линейному поиску в связном списке.

![Constant Hash](./hash_data/Always%20return%201%20(const).png)

### 2. Длина ключа

Функция `hashKeyLength()` длину слова-ключа. Хотя ее значение не является одинаковым для всех ключей, длина английских слов слабо варьируется, причем некоторые значения длин встречаются чаще других. Такая функция не дает равномерное распределение и имеет слишком узкий диапазон значений, следовательно, это плохая функция.

![Key Length](./hash_data/Key%20length%20(zoomed).png)


### 3. Первая буква ключа

Функция `hashFirstLetter()` возвращает первую букву ключа. Она лучше, чем константа и чем длина слова, но диапазон значений букв слова узок (26 или 52, если различать заглавные и строчные буквы). Поэтому такая функция довольно плохая. 

![First Letter Zoomed](./hash_data/First%20letter%20(zoomed).png)

### 4. Контрольная сумма

Функция `hashChecksum()` вычисляет сумму ASCII кодов букв в ключе. При тестировании ее на хэш-таблицах размером порядка 500-600 может сложиться впечатление, что это хорошая хэш-функция. На гистограмме распределения есть пики и впадины, но в целом значения контрольной суммы захватывают весь диапазон номеров списков (так как берется остатков по модулю размера хэш-таблицы).

![Checksum small size](./hash_data/Checksum%20(599%20keys).png)

Но стоит помнить, что длина английских слов сильно ограничена,  поэтому ограничены будут и значения контрольной суммы. При рассмотрении данной функции на хэш-таблице большего размера можно заметить, что ее значения в основном не превосходят 2000, поэтому часть списков (в нашем случае, половина) не будет использоваться. Соответственно, это тоже плохая хэш-функция.

![Checksum big size](./hash_data/Checksum%20(4096%20keys).png)

### 5. Битовое вращение вправо с исключающим "или"

Рассмотрим битовое представление числа. Каждый бит сдвинем вправо на одну позицию, а младший бит поместим на позицию старшего. Проведенную операцию назовем битовым вращением вправо (или циклическим битовым сдвигом вправо), а полученное число -- ее результатом.

В языке Си нет стандартной функции для этой операции, поэтому реализуем ее самостоятельно и сравним ассемблерные листинги написанной функции при использовании ключей оптимизации `-O0` и `-O3`. Стоит отметить, что существует ассемблерная инструкция  `ror`, которая делает битовое вращение вправо.






